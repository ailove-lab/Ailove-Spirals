// Generated by CoffeeScript 1.12.7
var Butterfly, PI, Spiral, add, contour, cos, ctx, cvs, cx, cy, dif, dst, g2a, h, init, line, mul, p2c, p2l, p2n, point, rnd, sin, w,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

cvs = document.getElementById("cvs");

ctx = cvs.getContext("2d");

w = cvs.width;

h = cvs.height;

cx = w / 2;

cy = h / 2;

sin = Math.sin;

cos = Math.cos;

rnd = Math.random;

PI = Math.PI;

p2c = function(p) {
  return [p[1] * cos(p[0]), -p[1] * sin(p[0])];
};

p2l = function(p) {
  return Math.sqrt(p[0] * p[0] + p[1] * p[1]);
};

p2n = function(p) {
  var l;
  l = p2l(p);
  return [p[0] / l, p[1] / l];
};

dst = function(p, q) {
  return p2l(dif(q, p));
};

dif = function(p, q) {
  return [p[0] - q[0], p[1] - q[1]];
};

add = function(p, q) {
  return [p[0] + q[0], p[1] + q[1]];
};

mul = function(p, k) {
  return [p[0] * k, p[1] * k];
};

g2a = function(g) {
  return g * PI / 180.0;
};

point = function(p) {
  var r;
  r = 5;
  ctx.save();
  ctx.beginPath();
  ctx.strokeStyle = "red";
  ctx.moveTo(p[0] - r, p[1]);
  ctx.lineTo(p[0] + r, p[1]);
  ctx.moveTo(p[0], p[1] - r);
  ctx.lineTo(p[0], p[1] + r);
  ctx.stroke();
  return ctx.restore();
};

line = function(p, q, c) {
  if (c == null) {
    c = "rgba(0,0,0,0.1)";
  }
  ctx.save();
  ctx.beginPath();
  ctx.strokeStyle = c;
  ctx.moveTo(p[0], p[1]);
  ctx.lineTo(q[0], q[1]);
  ctx.stroke();
  return ctx.restore();
};

contour = function(cnt, c) {
  var i, j, ref;
  ctx.save();
  if (c == null) {
    c = "rgba(0,0,0,0.1)";
  }
  ctx.beginPath();
  ctx.moveTo(cnt[0][0], cnt[0][1]);
  for (i = j = 1, ref = cnt.length; 1 <= ref ? j < ref : j > ref; i = 1 <= ref ? ++j : --j) {
    ctx.lineTo(cnt[i][0], cnt[i][1]);
  }
  ctx.strokeStyle = c;
  ctx.stroke();
  return ctx.restore();
};

Butterfly = (function() {
  function Butterfly() {
    this.draw = bind(this.draw, this);
    this.build = bind(this.build, this);
    this.wings_formula = bind(this.wings_formula, this);
    var c, f, i, j, len, len1, len2, o, p, r, ref, ref1, ref2, s, u;
    s = sin;
    c = cos;
    this.w_n = 6;
    this.w_c = 8;
    ref = [-1, +2, +2, -1, +3, -2];
    for (i = j = 0, len = ref.length; j < len; i = ++j) {
      r = ref[i];
      this["w_r_" + i] = r;
    }
    ref1 = [1, 3, 5, 7, 2, 4];
    for (i = o = 0, len1 = ref1.length; o < len1; i = ++o) {
      p = ref1[i];
      this["w_p_" + i] = p;
    }
    ref2 = [s, s, s, s, c, c];
    for (i = u = 0, len2 = ref2.length; u < len2; i = ++u) {
      f = ref2[i];
      this["w_f_" + i] = f;
    }
    this.build();
  }

  Butterfly.prototype.wings_formula = function(a) {
    var f, i, j, ref;
    f = this.w_c;
    for (i = j = 0, ref = this.w_n; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
      f += this["w_r_" + i] * this["w_f_" + i](this["w_p_" + i] * a);
    }
    return f;
  };

  Butterfly.prototype.build = function() {
    var a, g, r;
    return this.main_contour = (function() {
      var j, results;
      results = [];
      for (g = j = 90; j <= 450; g = ++j) {
        a = g2a(g);
        r = this.wings_formula(a);
        results.push(add([cx, cy], p2c([a, 40 * r])));
      }
      return results;
    }).call(this);
  };

  Butterfly.prototype.draw = function() {
    return contour(this.main_contour, "rgba(0,0,0,0.25)");
  };

  return Butterfly;

})();

Spiral = (function() {
  function Spiral(steps, radius, flex, br_step) {
    this.steps = steps;
    this.radius = radius;
    this.flex = flex;
    this.br_step = br_step != null ? br_step : 100;
    this.draw2 = bind(this.draw2, this);
    this.draw = bind(this.draw, this);
    this.dots = false;
    this.branches = false;
  }

  Spiral.prototype.draw = function(p, v, t, s) {
    var d, i, j, k, m, mm, n, nn, pv, r, ref, results, tt, vv;
    if (s == null) {
      s = 1;
    }
    if (this.dots) {
      point(p);
    }
    if (this.dots) {
      point(t);
    }
    p = p;
    r = this.radius;
    k = this.flex;
    results = [];
    for (i = j = 0, ref = this.steps; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
      n = p2n(dif(t, p));
      m = [s * n[1], -s * n[0]];
      d = add(t, mul(m, r));
      vv = p2n(dif(d, p));
      v = [v[0] + (vv[0] - v[0]) / k, v[1] + (vv[1] - v[1]) / k];
      pv = add(p, mul(v, 10));
      line(p, pv, "rgba(0,0,0,0.5)");
      if (this.branches && (i + 1) % this.br_step === 0) {
        nn = p2n(dif(pv, p));
        mm = [s * nn[1], -s * nn[0]];
        tt = add(p, mul(mm, r / 2.0));
        this.draw2(p, nn, tt, s);
      }
      p = pv;
      r -= 1;
      if (dst(p, t) < 3) {
        break;
      } else {
        results.push(void 0);
      }
    }
    return results;
  };

  Spiral.prototype.draw2 = function(p, v, t, s) {
    var d, i, j, k, m, n, pv, r, ref, results, vv;
    if (s == null) {
      s = 1;
    }
    if (this.dots) {
      point(t);
    }
    p = p;
    r = this.radius / 5.0;
    k = this.flex;
    results = [];
    for (i = j = 0, ref = this.steps; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
      n = p2n(dif(t, p));
      m = [-s * n[1], s * n[0]];
      d = add(t, mul(m, r));
      vv = p2n(dif(d, p));
      v = [v[0] + (vv[0] - v[0]) / k, v[1] + (vv[1] - v[1]) / k];
      pv = add(p, mul(v, 5));
      line(p, pv, "rgba(0,0,0,0.3)");
      p = pv;
      r -= 0.5;
      if (dst(p, t) < 3) {
        break;
      } else {
        results.push(void 0);
      }
    }
    return results;
  };

  return Spiral;

})();

init = function() {
  var b, f, g, i, j, o, redraw, ref, ref1, results, s;
  b = new Butterfly;
  s = new Spiral(200, 200, 5.0);
  s.spiral_step = 30;
  redraw = function() {
    var i, j, mc, n, p1, p2, ref, results, spin, t, v;
    ctx.clearRect(0, 0, w, h);
    b.build();
    b.draw();
    mc = b.main_contour;
    results = [];
    for (i = j = 30, ref = s.spiral_step; j <= 330; i = j += ref) {
      if (i % 180 === 0) {
        continue;
      }
      switch (true) {
        case (0 < i && i < 90):
          spin = -1;
          v = [0, 1];
          break;
        case (90 <= i && i < 180):
          spin = 1;
          v = [0, -1];
          break;
        case (180 < i && i < 270):
          spin = -1;
          v = [0, -1];
          break;
        case (270 < i && i < 360):
          spin = 1;
          v = [0, 1];
      }
      p1 = [mc[i][0], mc[i][1]];
      p2 = [mc[i + 1][0], mc[i + 1][1]];
      n = p2n(dif(p2, p1));
      n = [n[1], -n[0]];
      t = add(p1, mul(n, 100));
      line(t, p1);
      results.push(s.draw([cx, cy], v, t, spin));
    }
    return results;
  };
  redraw();
  g = new dat.GUI();
  f = g.addFolder("Curls");
  f.add(s, "spiral_step", 10, 90, 10).onChange(redraw);
  f.add(s, "radius", 0, 1000).onChange(redraw);
  f.add(s, "steps", 0, 1000).onChange(redraw);
  f.add(s, "flex", 1.0, 100).onChange(redraw);
  f.add(s, "branches").onChange(redraw);
  f.add(s, "br_step", 10, 200, 1).onChange(redraw);
  f.add(s, "dots").onChange(redraw);
  f.open();
  f = g.addFolder("Wings");
  for (i = j = 0, ref = b.w_n; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
    f.add(b, "w_r_" + i, -10, 10).onChange(redraw);
  }
  results = [];
  for (i = o = 0, ref1 = b.w_n; 0 <= ref1 ? o < ref1 : o > ref1; i = 0 <= ref1 ? ++o : --o) {
    results.push(f.add(b, "w_p_" + i, 0, 20, 1).onChange(redraw));
  }
  return results;
};

window.onload = init;
